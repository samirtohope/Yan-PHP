<?php
/**
 * Yan Framework
 *
 * @copyright Copyright (c) 2011-2012 kakalong (http://yanbingbing.com)
 */

/**
 * Yan_Db_Adapter
 *
 * @category   Yan
 * @package    Yan_Db
 * @subpackage Adapter
 */
abstract class Yan_Db_Adapter
{

	/**
	 * User-provided configuration
	 *
	 * @var array
	 */
	protected $_config = array();

	/**
	 * Fetch mode
	 *
	 * @var integer
	 */
	protected $_fetchMode = Yan_Db::FETCH_ASSOC;

	/**
	 * Database connection
	 *
	 * @var PDO
	 */
	protected $_connection = null;

	/**
	 * Specifies the case of column names retrieved in queries
	 * Options
	 * Yan_Db::CASE_NATURAL (default)
	 * Yan_Db::CASE_LOWER
	 * Yan_Db::CASE_UPPER
	 *
	 * @var integer
	 */
	protected $_caseFolding = Yan_Db::CASE_NATURAL;

	/**
	 * Specifies whether the adapter automatically quotes identifiers.
	 * If true, most SQL generated by Yan_Db classes applies
	 * identifier quoting automatically.
	 * If false, developer must quote identifiers themselves
	 * by calling quoteIdentifier().
	 *
	 * @var bool
	 */
	protected $_autoQuoteIdentifiers = true;

	/**
	 * Keys are UPPERCASE SQL datatypes or the constants
	 * Yan_Db::INT_TYPE, Yan_Db::BIGINT_TYPE, or Yan_Db::FLOAT_TYPE.
	 *
	 * Values are:
	 * 0 = 32-bit integer
	 * 1 = 64-bit integer
	 * 2 = float or decimal
	 *
	 * @var array Associative array of datatypes to values 0, 1, or 2.
	 */
	protected $_numericDataTypes = array(
		Yan_Db::INT_TYPE => Yan_Db::INT_TYPE,
		Yan_Db::BIGINT_TYPE => Yan_Db::BIGINT_TYPE,
		Yan_Db::FLOAT_TYPE => Yan_Db::FLOAT_TYPE
	);

	protected $_options = array(
		'host' => true,
		'port' => false,
		'password' => true,
		'username' => true,
		'charset' => false,
		'dbname' => true,
		'prefix' => false,
		'persistent' => false,
		'driver_options' => false
	);

	protected $_driver = 'pdo';

	/**
	 * Constructor.
	 *
	 * $config is an array of key/value pairs or an instance of Zend_Config
	 * containing configuration options.  These options are common to most adapters:
	 *
	 * dbname         => (string) The name of the database to user
	 * username       => (string) Connect to the database as this username.
	 * password       => (string) Password associated with the username.
	 * host           => (string) What host to connect to, defaults to localhost
	 *
	 * Some options are used on a case-by-case basis by adapters:
	 *
	 * port           => (string) The port of the database
	 * caseFolding    => (int) style of case-alteration used for identifiers
	 * fetchMode      => (int) style of fetch data
	 * charset        => (string) charset of collection
	 * prefix         => (string) prefix of table name
	 *
	 * @param  mixed $config
	 * @throws Yan_Db_Adapter_Exception
	 */
	public function __construct($config)
	{
		/*
		 * Verify that adapter parameters are in an array.
		 */
		if (!is_array($config)) {
			/*
			 * Convert object argument to a plain array.
			 */
			if (is_object($config) && method_exists($config, 'toArray')) {
				$config = $config->toArray();
			} else {
				require_once 'Yan/Db/Adapter/Exception.php';
				throw new Yan_Db_Adapter_Exception('Adapter parameters must be in an array or a object');
			}
		}

		if (isset($config[Yan_Db::CASE_FOLDING])) {
			$case = (int)$config[Yan_Db::CASE_FOLDING];
			switch ($case) {
			case Yan_Db::CASE_LOWER:
			case Yan_Db::CASE_UPPER:
			case Yan_Db::CASE_NATURAL:
				$this->_caseFolding = $case;
				break;
			}
		}

		if (isset($config[Yan_Db::FETCH_MODE])) {
			$mode = $config[Yan_Db::FETCH_MODE];
			if (is_string($mode)) {
				$constant = 'Yan_Db::FETCH_' . strtoupper($mode);
				if (defined($constant)) {
					$mode = constant($constant);
				}
			}
			$this->setFetchMode((int)$mode);
		}

		foreach ($this->_options as $key => $optional) {
			if (isset($config[$key])) {
				$this->_config[$key] = $config[$key];
			} elseif ($optional) {
				require_once 'Yan/Db/Adapter/Exception.php';
				throw new Yan_Db_Adapter_Exception(
					"Configuration array must have a key for '$key' that names the database instance"
				);
			}
		}
	}

	abstract protected function _dsn();

	protected function _connect()
	{
		// if we already have a PDO object, no need to re-connect.
		if ($this->_connection) {
			return;
		}

		// get the dsn first, because some adapters alter the $_pdoType
		$dsn = $this->_dsn();

		// check for PDO extension
		if (!extension_loaded('pdo')) {
			require_once 'Yan/Db/Adapter/Exception.php';
			throw new Yan_Db_Adapter_Exception('The PDO extension is required for this adapter but the extension is not loaded');
		}

		// check the PDO driver is available
		if (!in_array($this->_driver, PDO::getAvailableDrivers())) {
			require_once 'Yan/Db/Adapter/Exception.php';
			throw new Yan_Db_Adapter_Exception('The ' . $this->_driver . ' driver is not currently installed');
		}

		// add the persistence flag if we find it in our config array
		if (isset($this->_config['persistent']) && ($this->_config['persistent'] == true)) {
			$this->_config['driver_options'][PDO::ATTR_PERSISTENT] = true;
		}

		try {
			$this->_connection = new PDO(
				$dsn,
				$this->_config['username'],
				$this->_config['password'],
				$this->_config['driver_options']
			);

			// set the PDO connection to perform case-folding on array keys, or not
			$this->_connection->setAttribute(PDO::ATTR_CASE, $this->_caseFolding);

			// always use exceptions.
			$this->_connection->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);

		} catch (PDOException $e) {
			require_once 'Yan/Db/Adapter/Exception.php';
			throw new Yan_Db_Adapter_Exception($e->getMessage(), $e->getCode());
		}
	}

	/**
	 * Returns the underlying database connection object or resource.
	 * If not presently connected, this initiates the connection.
	 *
	 * @return PDO|null
	 */
	public function getConnection()
	{
		$this->_connect();
		return $this->_connection;
	}

	/**
	 * Test if a connection is active
	 *
	 * @return boolean
	 */
	public function isConnected()
	{
		return ((bool)($this->_connection instanceof PDO));
	}

	/**
	 * create a select
	 *
	 * @return Yan_Db_Select
	 */
	public function select()
	{
		return new Yan_Db_Select($this);
	}

	/**
	 * Prepares and executes an SQL statement with bound data.
	 *
	 * @param $statement
	 * @throws Yan_Db_Adapter_Exception
	 * @return int
	 */
	public function exec($statement)
	{
		if ($statement instanceof Yan_Db_Select) {
			$statement = $statement->assemble();
		}
		try {
			$this->_connect();
			$stmt = $this->prepare($statement);
			$stmt->execute();
			$affected = $stmt->rowCount();

			if ($affected === false) {
				$errorInfo = $stmt->errorInfo();
				require_once 'Yan/Db/Adapter/Exception.php';
				throw new Yan_Db_Adapter_Exception($errorInfo[2]);
			}

			return $affected;
		} catch (Yan_Db_Statement_Exception $e) {
			require_once 'Yan/Db/Adapter/Exception.php';
			throw new Yan_Db_Adapter_Exception($e->getMessage(), $e->getCode());
		}
	}

	/**
	 * Prepares and executes an SQL statement with bound data.
	 *
	 * @param  mixed  $sql  The SQL statement with placeholders.
	 *                      May be a string or Db_Select.
	 * @param  mixed  $bind An array of data to bind to the placeholders.
	 * @return Yan_Db_Statement
	 */
	public function query($sql, $bind = array())
	{
		// connect to database if need
		$this->_connect();

		// is the $sql a Yan_Db_Select object?
		if ($sql instanceof Yan_Db_Select) {
			if (empty($bind)) {
				$bind = $sql->getBind();
			}

			$sql = $sql->assemble();
		}

		// make sure $bind to an array;
		if (is_array($bind)) {
			foreach ($bind as $name => $value) {
				if (!is_int($name) && $name{0} != ':') {
					$newName = ":$name";
					unset($bind[$name]);
					$bind[$newName] = $value;
				}
			}
		} else {
			$bind = array($bind);
		}

		$stmt = $this->prepare($sql);
		$stmt->execute($bind);

		// return the results embedded in the prepared statement object
		$stmt->setFetchMode($this->_fetchMode);
		return $stmt;
	}

	public function getFetchMode()
	{
		return $this->_fetchMode;
	}

	/**
	 * Leave autocommit mode and begin a transaction.
	 *
	 * @return bool True
	 */
	public function beginTransaction()
	{
		return $this->getConnection()->beginTransaction();
	}

	/**
	 * Commit a transaction and return to autocommit mode.
	 *
	 * @return bool True
	 */
	public function commit()
	{
		return $this->getConnection()->commit();
	}

	/**
	 * Roll back a transaction and return to autocommit mode.
	 *
	 * @return bool True
	 */
	public function rollBack()
	{
		return $this->getConnection()->rollBack();
	}

	/**
	 * Checks if a transaction is currently active within the driver.
	 *
	 * @return bool
	 */
	public function inTransaction()
	{
		return $this->getConnection()->inTransaction();
	}

	/**
	 * Fetches all SQL result rows as a sequential array.
	 * Uses the current fetchMode for the adapter.
	 *
	 * @param string|Yan_Db_Select $sql  An SQL SELECT statement.
	 * @param mixed                 $bind Data to bind into SELECT placeholders.
	 * @param mixed                 $fetchMode Override current fetch mode.
	 * @return array
	 */
	public function fetchAll($sql, $bind = array(), $fetchMode = null)
	{
		if ($fetchMode === null) {
			$fetchMode = $this->_fetchMode;
		}
		$stmt = $this->query($sql, $bind);
		$result = $stmt->fetchAll($fetchMode);
		return $result;
	}

	/**
	 * Fetches the first row of the SQL result.
	 * Uses the current fetchMode for the adapter.
	 *
	 * @param string|Yan_Db_Select $sql An SQL SELECT statement.
	 * @param mixed $bind Data to bind into SELECT placeholders.
	 * @param mixed                 $fetchMode Override current fetch mode.
	 * @return array
	 */
	public function fetchRow($sql, $bind = array(), $fetchMode = null)
	{
		if ($fetchMode === null) {
			$fetchMode = $this->_fetchMode;
		}
		$stmt = $this->query($sql, $bind);
		$result = $stmt->fetch($fetchMode);
		return $result;
	}

	/**
	 * Fetches all SQL result rows as an associative array.
	 *
	 * The first column is the key, the entire row array is the
	 * value.  You should construct the query to be sure that
	 * the first column contains unique values, or else
	 * rows with duplicate values in the first column will
	 * overwrite previous data.
	 *
	 * @param string|Yan_Db_Select $sql An SQL SELECT statement.
	 * @param mixed $bind Data to bind into SELECT placeholders.
	 * @return string
	 */
	public function fetchAssoc($sql, $bind = array())
	{
		$stmt = $this->query($sql, $bind);
		$data = array();
		while (($row = $stmt->fetch(Yan_Db::FETCH_ASSOC)) != false) {
			$tmp = array_values(array_slice($row, 0, 1));
			$data[$tmp[0]] = $row;
		}
		return $data;
	}

	/**
	 * Fetches the first column of all SQL result rows as an array.
	 *
	 * The first column in each row is used as the array key.
	 *
	 * @param string|Yan_Db_Select $sql An SQL SELECT statement.
	 * @param mixed $bind Data to bind into SELECT placeholders.
	 * @return array
	 */
	public function fetchCol($sql, $bind = array())
	{
		$stmt = $this->query($sql, $bind);
		$result = $stmt->fetchAll(Yan_Db::FETCH_COLUMN, 0);
		return $result;
	}

	/**
	 * Fetches all SQL result rows as an array of key-value pairs.
	 *
	 * The first column is the key, the second column is the
	 * value.
	 *
	 * @param string|Yan_Db_Select $sql An SQL SELECT statement.
	 * @param mixed $bind Data to bind into SELECT placeholders.
	 * @return string
	 */
	public function fetchPairs($sql, $bind = array())
	{
		$stmt = $this->query($sql, $bind);
		$data = array();
		while (($row = $stmt->fetch(Yan_Db::FETCH_NUM)) != false) {
			$data[$row[0]] = $row[1];
		}
		return $data;
	}

	/**
	 * Fetches the first column of the first row of the SQL result.
	 *
	 * @param string|Yan_Db_Select $sql An SQL SELECT statement.
	 * @param mixed $bind Data to bind into SELECT placeholders.
	 * @return string
	 */
	public function fetchOne($sql, $bind = array())
	{
		$stmt = $this->query($sql, $bind);
		$result = $stmt->fetchColumn(0);
		return $result;
	}

	public function insert($table, array $bind, $hasQuoted = false)
	{
		// extract and quote col names from the array keys
		$cols = array();
		$vals = array();
		foreach ($bind as $col => $val) {
			$cols[] = $this->quoteIdentifier($col, true);
			if ($val instanceof Yan_Db_Expr) {
				$vals[] = $val->__toString();
				unset($bind[$col]);
			} else {
				$vals[] = ':' . $col;
			}
		}

		if (!$hasQuoted) {
			$table = $this->quoteTableAs($table, null, true);
		}

		// build the statement
		$sql = "INSERT INTO $table"
			. ' (' . implode(', ', $cols) . ') '
			. 'VALUES (' . implode(', ', $vals) . ')';
		// execute the statement and return the number of affected rows
		$stmt = $this->query($sql, $bind);
		$result = $stmt->rowCount();
		return $result;
	}

	/**
	 * Updates table rows with specified data based on a WHERE clause.
	 *
	 * @param  mixed $table The table to update.
	 * @param  array $bind  Column-value pairs.
	 * @param  mixed $where UPDATE WHERE clause(s).
	 * @param  bool $hasQuoted
	 * @return int The number of affected rows.
	 */
	public function update($table, array $bind, $where = '', $hasQuoted = false)
	{
		$set = array();
		foreach ($bind as $col => $val) {
			if ($val instanceof Yan_Db_Expr) {
				$val = $val->__toString();
				unset($bind[$col]);
			} else {
				$val = ':' . $col;
			}
			$set[] = $this->quoteIdentifier($col, true) . ' = ' . $val;
		}

		$where = $this->whereExpr($where);

		if (!$hasQuoted) {
			$table = $this->quoteTableAs($table, null, true);
		}
		/**
		 * Build the UPDATE statement
		 */
		$sql = "UPDATE $table"
			. ' SET ' . implode(', ', $set)
			. (($where) ? " WHERE $where" : '');

		/**
		 * Execute the statement and return the number of affected rows
		 */
		$stmt = $this->query($sql, $bind);
		$result = $stmt->rowCount();
		return $result;
	}

	/**
	 * Deletes table rows based on a WHERE clause.
	 *
	 * @param  mixed  $table The table to update.
	 * @param  mixed  $where DELETE WHERE clause(s).
	 * @param bool    $hasQuoted
	 * @return int    The number of affected rows.
	 */
	public function delete($table, $where = '', $hasQuoted = false)
	{
		$where = $this->whereExpr($where);

		if (!$hasQuoted) {
			$table = $this->quoteTableAs($table, null, true);
		}

		/**
		 * Build the DELETE statement
		 */
		$sql = "DELETE FROM $table" . (($where) ? " WHERE $where" : '');

		/**
		 * Execute the statement and return the number of affected rows
		 */
		$stmt = $this->query($sql);
		$result = $stmt->rowCount();
		return $result;
	}

	public function whereExpr($where, $join = ' AND ')
	{
		if (!is_array($where)) {
			return (string)$where;
		}
		if (empty($where)) {
			return '';
		}
		foreach ($where as $cond => &$term) {
			if (is_int($cond)) {
				$cond = $term;
				$term = null;
				if (is_array($cond)) {
					$term = $this->whereExpr($cond);
					continue;
				}
			}
			$term = '(' . $this->cond($cond, $term) . ')';
		}
		return implode($join, $where);
	}

	public function cond($expr, $value = null, $type = null)
	{
		if ($value === null || !is_string($expr)) {
			return (string)$expr;
		}
		if (!$expr) {
			return '';
		}
		if (($pos = strpos($expr, '?')) !== false) {
			if (is_array($value)) {
				for ($i = 0, $l = count($value); $i < $l; $i++) {
					$val = $this->quote($value[$i], $type);
					$expr = substr_replace($expr, $val, $pos, 1);
					$pos = strpos($expr, '?', $pos + strlen($val));
					if (!$pos) break;
				}
				return $expr;
			} else {
				return str_replace('?', $this->quote($value, $type), $expr);
			}
		}
		$column = str_replace($this->getQuoteIdentifierSymbol(), '', $expr);
		if (preg_match('/[^\w\.]/', $column)) {
			return $expr;
		}
		$column = $this->_quoteIdentifierAs($column, null, true);
		if (is_array($value)) {
			if (!$value) {
				return '';
			}
			foreach ($value as &$a) {
				$a = $this->quote($a, $type);
			}
			$value = ' IN (' . implode(', ', $value) . ')';
		} else {
			$value = ' = ' . $this->quote($value, $type);
		}
		return $column . $value;
	}

	/**
	 * Quote a raw string.
	 *
	 * @param string $value     Raw string
	 * @return string           Quoted string
	 */
	protected function _quote($value)
	{
		if (is_int($value) || is_float($value)) {
			return $value;
		}
		$this->_connect();
		return $this->_connection->quote($value);
	}

	/**
	 * Safely quotes a value for an SQL statement.
	 *
	 * If an array is passed as the value, the array values are quoted
	 * and then returned as a comma-separated string.
	 *
	 * @param mixed $value The value to quote.
	 * @param mixed $type  OPTIONAL the SQL datatype name, or constant, or null.
	 * @return mixed An SQL-safe quoted value (or string of separated values).
	 */
	public function quote($value, $type = null)
	{
		$this->_connect();

		if ($value instanceof Yan_Db_Select) {
			return '(' . $value->assemble() . ')';
		}

		if ($value instanceof Yan_Db_Expr) {
			return $value->__toString();
		}

		if (is_array($value)) {
			foreach ($value as &$val) {
				$val = $this->quote($val, $type);
			}
			return implode(', ', $value);
		}

		if ($type !== null && array_key_exists($type = strtoupper($type), $this->_numericDataTypes)) {
			$quotedValue = '0';
			switch ($this->_numericDataTypes[$type]) {
			case Yan_Db::INT_TYPE: // 32-bit integer
				$quotedValue = (string)intval($value);
				break;
			case Yan_Db::BIGINT_TYPE: // 64-bit integer
				// ANSI SQL-style hex literals (e.g. x'[\dA-F]+')
				// are not supported here, because these are string
				// literals, not numeric literals.
				if (preg_match('/^(
						  [+-]?                  # optional sign
						  (?:
							0[Xx][\da-fA-F]+     # ODBC-style hexadecimal
							|\d+                 # decimal or octal, or MySQL ZEROFILL decimal
							(?:[eE][+-]?\d+)?    # optional exponent on decimals or octals
						  )
						)/x',
					(string)$value, $matches)
				) {
					$quotedValue = $matches[1];
				}
				break;
			case Yan_Db::FLOAT_TYPE: // float or decimal
				$quotedValue = sprintf('%F', $value);
			}
			return $quotedValue;
		}

		return $this->_quote($value);
	}

	/**
	 * Quotes a value and places into a piece of text at a placeholder.
	 *
	 * The placeholder is a question-mark; all placeholders will be replaced
	 * with the quoted value.   For example:
	 *
	 * <code>
	 * $text = "WHERE date < ?";
	 * $date = "2005-01-02";
	 * $safe = $sql->quoteInto($text, $date);
	 * // $safe = "WHERE date < '2005-01-02'"
	 * </code>
	 *
	 * @param string  $text  The text with a placeholder.
	 * @param mixed   $value The value to quote.
	 * @param string  $type  OPTIONAL SQL datatype
	 * @param integer $count OPTIONAL count of placeholders to replace
	 * @return string An SQL-safe quoted value placed into the original text.
	 */
	public function quoteInto($text, $value, $type = null, $count = null)
	{
		if ($count === null) {
			return str_replace('?', $this->quote($value, $type), $text);
		} else {
			while ($count > 0) {
				if (strpos($text, '?') != false) {
					$text = substr_replace($text, $this->quote($value, $type), strpos($text, '?'), 1);
				}
				--$count;
			}
			return $text;
		}
	}

	/**
	 * Quotes an identifier.
	 *
	 * Accepts a string representing a qualified indentifier. For Example:
	 * <code>
	 * $adapter->quoteIdentifier('myschema.mytable')
	 * </code>
	 * Returns: "myschema"."mytable"
	 *
	 * Or, an array of one or more identifiers that may form a qualified identifier:
	 * <code>
	 * $adapter->quoteIdentifier(array('myschema','my.table'))
	 * </code>
	 * Returns: "myschema"."my.table"
	 *
	 * The actual quote character surrounding the identifiers may vary depending on
	 * the adapter.
	 *
	 * @param string|array|Yan_Db_Expr $ident The identifier.
	 * @param boolean $auto If true, heed the AUTO_QUOTE_IDENTIFIERS config option.
	 * @return string The quoted identifier.
	 */
	public function quoteIdentifier($ident, $auto = false)
	{
		return $this->_quoteIdentifierAs($ident, null, $auto);
	}

	/**
	 * Quote a column identifier and alias.
	 *
	 * @param string|array|Yan_Db_Expr $ident The identifier or expression.
	 * @param string $alias An alias for the column.
	 * @param boolean $auto If true, heed the AUTO_QUOTE_IDENTIFIERS config option.
	 * @return string The quoted identifier and alias.
	 */
	public function quoteColumnAs($ident, $alias, $auto = false)
	{
		return $this->_quoteIdentifierAs($ident, $alias, $auto);
	}

	/**
	 * Quote a table identifier and alias.
	 *
	 * @param string|array|Yan_Db_Expr $ident The identifier or expression.
	 * @param string $alias An alias for the table.
	 * @param boolean $auto If true, heed the AUTO_QUOTE_IDENTIFIERS config option.
	 * @return string The quoted identifier and alias.
	 */
	public function quoteTableAs($ident, $alias = null, $auto = false)
	{
		return $this->_quoteTableAs($ident, $alias, $auto);
	}

	/**
	 * Quote a table identifier and alias.
	 *
	 * @param string|array|Yan_Db_Expr $ident The identifier or expression.
	 * @param string $alias An alias for the table.
	 * @param boolean $auto If true, heed the AUTO_QUOTE_IDENTIFIERS config option.
	 * @param string $as The string to add between the identifier/expression and the alias.
	 * @return string The quoted identifier and alias.
	 */
	protected function _quoteTableAs($ident, $alias = null, $auto = false, $as = ' AS ')
	{
		if ($ident instanceof Yan_Db_Expr) {
			$quoted = $ident->__toString();
		} else {
			if (!is_array($ident)) {
				$ident = explode('.', $ident);
			}
			$schema = null;
			$table = $ident[0];
			if (isset($ident[1])) {
				$schema = $table;
				$table = $ident[1];
			}
			$quoted = '';
			if ($schema) {
				$quoted = $this->_quoteIdentifier($schema, $auto) . '.';
			}
			if ($table instanceof Yan_Db_Expr) {
				$quoted .= $table->__toString();
			} else {
				$table = $this->_config['prefix'] . $table;
				if ($alias == $table) {
					$alias = null;
				}
				$quoted .= $this->_quoteIdentifier($table, $auto);
			}
		}
		if ($alias !== null) {
			$quoted .= $as . $this->_quoteIdentifier($alias, $auto);
		}
		return $quoted;
	}

	/**
	 * Quote an identifier and an optional alias.
	 *
	 * @param string|array|Yan_Db_Expr|Yan_Db_Select $ident The identifier or expression.
	 * @param string $alias An optional alias.
	 * @param boolean $auto If true, heed the AUTO_QUOTE_IDENTIFIERS config option.
	 * @return string The quoted identifier and alias.
	 */
	protected function _quoteIdentifierAs($ident, $alias = null, $auto = false)
	{
		if ($ident instanceof Yan_Db_Expr) {
			$quoted = $ident->__toString();
		} elseif ($ident instanceof Yan_Db_Select) {
			$quoted = '(' . $ident->assemble() . ')';
		} else {
			if (is_string($ident)) {
				$ident = explode('.', $ident);
			}
			if (is_array($ident)) {
				$segments = array();
				foreach ($ident as $segment) {
					if ($segment instanceof Yan_Db_Expr) {
						$segments[] = $segment->__toString();
					} else {
						$segments[] = $this->_quoteIdentifier($segment, $auto);
					}
				}
				if ($alias !== null && end($ident) == $alias) {
					$alias = null;
				}
				$quoted = implode('.', $segments);
			} else {
				$quoted = $this->_quoteIdentifier($ident, $auto);
			}
		}
		if ($alias !== null) {
			$quoted .= ' AS ' . $this->_quoteIdentifier($alias, $auto);
		}
		return $quoted;
	}

	/**
	 * Quote an identifier.
	 *
	 * @param  string $value The identifier or expression.
	 * @param boolean $auto If true, heed the AUTO_QUOTE_IDENTIFIERS config option.
	 * @return string        The quoted identifier and alias.
	 */
	protected function _quoteIdentifier($value, $auto = false)
	{
		if ($auto === false || $this->_autoQuoteIdentifiers === true) {
			$q = $this->getQuoteIdentifierSymbol();
			return ($q . str_replace("$q", "$q$q", $value) . $q);
		}
		return $value;
	}

	/**
	 * Returns the symbol the adapter uses for delimited identifiers.
	 *
	 * @return string
	 */
	public function getQuoteIdentifierSymbol()
	{
		return '"';
	}

	/**
	 * Prepare a statement and return a PDOStatement-like object.
	 *
	 * @param  string  $sql  SQL query
	 * @return Yan_Db_Statement
	 */
	public function prepare($sql)
	{
		$stmt = new Yan_Db_Statement($this, $sql);
		$stmt->setFetchMode($this->_fetchMode);
		return $stmt;
	}

	/**
	 * Force the connection to close.
	 *
	 * @return void
	 */
	public function close()
	{
		$this->_connection = null;
	}

	/**
	 * Return the most recent value from the specified sequence in the database.
	 * This is supported only on RDBMS brands that support sequences
	 * (e.g. Oracle, PostgreSQL, DB2).  Other RDBMS brands return null.
	 *
	 * @param string $sequenceName
	 * @return string
	 */
	public function lastSequenceId($sequenceName)
	{
		return null;
	}

	/**
	 * Gets the last ID generated automatically by an IDENTITY/AUTOINCREMENT column.
	 *
	 * As a convention, on RDBMS brands that support sequences
	 * (e.g. Oracle, PostgreSQL, DB2), this method forms the name of a sequence
	 * from the arguments and returns the last id generated by that sequence.
	 * On RDBMS brands that support IDENTITY/AUTOINCREMENT columns, this method
	 * returns the last value generated for such a column, and the table name
	 * argument is disregarded.
	 *
	 * @return string
	 */
	public function lastInsertId()
	{
		$this->_connect();
		return $this->_connection->lastInsertId();
	}

	/**
	 * Set the fetch mode.
	 *
	 * @param integer $mode
	 * @return void
	 * @throws Yan_Db_Adapter_Exception
	 */
	public function setFetchMode($mode)
	{
		switch ($mode) {
		case Yan_Db::FETCH_LAZY:
		case Yan_Db::FETCH_ASSOC:
		case Yan_Db::FETCH_NUM:
		case Yan_Db::FETCH_BOTH:
		case Yan_Db::FETCH_NAMED:
		case Yan_Db::FETCH_OBJ:
			$this->_fetchMode = $mode;
			break;
		default:
			require_once 'Yan/Db/Adapter/Exception.php';
			throw new Yan_Db_Adapter_Exception("Invalid fetch mode '$mode' specified");
			break;
		}
	}

	public function setAttribute($attribute, $value)
	{
		$this->_connect();
		return $this->_connection->setAttribute($attribute, $value);
	}

	/**
	 * Fetch extended error information associated with the last operation on the database handle
	 *
	 * @return array
	 */
	public function errorInfo()
	{
		return $this->isConnected() ? $this->_connection->errorInfo() : array(0 => Yan_Db::ERR_NONE);
	}

	/**
	 * Fetch the SQLSTATE associated with the last operation on the database handle
	 *
	 * @return mixed
	 */
	public function errorCode()
	{
		return $this->isConnected() ? $this->_connection->errorCode() : Yan_Db::ERR_NONE;
	}

	/**
	 * Returns the column descriptions for a table.
	 *
	 * The value of each array element is an associative array
	 * with the following keys:
	 *
	 * COLUMN_NAME    => string; column name
	 * COLUMN_POS    => number; ordinal position of column in table
	 * DATA_TYPE    => string; SQL datatype name of column
	 * DEFAULT        => string; default expression of column, null if none
	 * NULLABLE        => boolean; true if column can have nulls
	 * LENGTH        => number; length of CHAR/VARCHAR
	 * UNSIGNED        => boolean; unsigned property of an integer type
	 * PRIMARY        => boolean; true if column is part of the primary key
	 * PRIMARY_POS    => integer; position of column in primary key
	 * IDENTITY        => integer; true if column isautoIncrement
	 *
	 * @param string $table
	 * @param string $schema
	 * @param bool $hasQuoted
	 *
	 * @return array
	 */
	abstract public function describeTable($table, $schema = null, $hasQuoted = false);

	/**
	 * Adds an adapter-specific LIMIT clause to the SELECT statement.
	 *
	 * @param mixed $sql
	 * @param integer $count
	 * @param integer $offset
	 * @return string
	 */
	abstract public function limit($sql, $count, $offset = 0);
}